# 1. 解释器

## 调用解释器

- 启动：`python -c command [arg]`
- 调用模块：`python -m module [arg]`
- 需进入交互模式：`python -i FILE`

## 传参

- 库方法：`sys.argv`
- 参数会转字符串列表被模块接收

## 交互模式

- 主提示符：`>>>`
- 次提示符：`...`

## 解释器运行环境

### 源文件字符编码

- 默认：UTF-8 编码处理
- 使用其他编码，需在文件第一行书写特殊注释。
- 例如：`# -*- coding: encoding -*-`等等..

# 2. 大概介绍

- 注释有效范围：整行 | 代码行尾

## 作为计算器

### 数字

- 加减乘除与 `javascript` 差不多.
- 括号用于分组
- 整数：`int`（如：1）
- 浮点：`float`（如：1.0）
- 除法必定返回类型：浮点
- 取整结果可用方法：`//` | `%`
- 乘方：`**`
- 赋值：`=`
- 包含多种混合类型运算数的运算会把整数转为浮点数
- Python会将上一个打印值赋予变量：`_`
- 使用后缀 `j` | `J`可表示虚数部分（如：3+5j）

### 字符串

- 单双引号均可，`\`用于转译
- 字符串前使用`r`，可使字符串内容不背转译
- 跨行输入使用：`'''string'''` |  `"""string"""`
- 使用 `*`进行重复
- 使用 `+` 进行连接
- 相邻多个（字面量）字符串会被合并
- 可被索引，负数从右开始数
- 利用索引进行切片，截取字符串
- 字符串不可修改 | immutable

### 列表

- 通过一些值（多种复合数据类型）组成
- 可切片 | 返回新列表（浅拷贝）
- 切片可赋值
- 可索引
- 可修改 | mutable


### 编程第一步

- ```python
    # 斐波那契数列
    a, b = 0, 1
    while a < 10:
      print(a, end=", ") # 使用 , 代替换行
      a, b = b, a + b
    ```


# 3. 其他流程控制工具

## `if` 语句

- 关键词：`if` | `elif` | `else`

- ``` python
  x = 10
  if x < 0:
    x = 0
    print("Hello. I'm Zero")
  elif x == 5:
    print("Hello. I'm Five")
  else:
    print("Hello.")
  ```

## `for` 语句

- 关键词：`for  in`

- ``` python
  words = ["huang", "jing", "chu"]
  for word in words:
      print(word, len(word))
  ```

## `range(start, end, step)`函数

- 生成一个数列

- 参数 `step` 使其返回步进的值

- ``` python
  for n in range(5):
    print(n, end = ", ")
  >>> 0, 1, 2, 3, 4
  ```

- ``` python
  for n in rannge(0, 10, 3):
    print(n, end = ", ")
  >>> 0, 3, 6, 9
  ```

- ``` python
  # 遍历字符串
  name = ['huang', 'jing', 'chu']
  for i in range(len(name)):
      print(i, name[i])
  ```

## `break` 和 `continue` 语句， 循环中 `esle` 子句

- `break` 用于跳出最近的`for` | `while` 循环
- 循环语句中带有 `else` 子句时，会执行在`for`循环耗尽可迭代对象时 | `while` 循环条件为假值时
- 循环中的`else`子句在未发生`break`时执行
- `try`语句中的`else`子句在未捕捉异常时执行
- `continue`继续循环中的下一次迭代

## `pass`语句

- 什么也不做

- 编写代码时，可作为临时占位符，保持抽象层次思考

- ``` python
  while True:
    pass
  ```

## 定义函数

- 关键字：`def`

- 后跟函数和括号，且下行必须缩进

- 没有`return`语句时，会默认返回`None`

- ``` python
  def someNum(num):
    a, b = 0, 1
    while a < num:
      print(a, end = " ")
      a, b = b, a + b
  ```

## 定义函数的其他形式

- 定义参数默认值

  - ``` pythonn
    def simple(arg1, arg2 = "leo", arg3 = 3)
    ```

  - 默认值只执行一次，该规则在默认值可变时很重要

  - 执行函数多次，它们之间共享默认值

- 关键字参数

  - 调用函数时给予参数赋值
  - 不可重复赋值
  - 如有`**name`作为最后一个形参时，它会接受一个字典（key-value）
  - 如有`*name`作为形参时，他会接受除已有形参列表以外位置参数的元组形参
  - `*name` 必须出现在`**name`之前

- 特殊参数

  - 默认情况，函数传参是 位置参数 或是 显式关键字参数（如函数定义中未使用`/`和`*`）

  - 仅限位置参数：首先函数定义中包含`/`，其次其参要放在`/`之前

  - 仅限关键字参数：指明参数必以关键字形式传入，应在参数列表第一个仅限关键字形参前放置`*`

  - ``` python
    def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
          -----------    ----------     ----------
            |             |                  |
            |        Positional or keyword   |
            |                                - Keyword only
             -- Positional only
    ```

  - ``` python
    1.常见形式：无调用限制
    def huang(arg):
    >>> huang(1) | huang(arg = 1)
    
    2.仅位置形参
    def jing(arg, /)
    >>> jing(1)
    
    3.仅关键字形参
    def chu(*, arg)
    >>> chu(arg = 1)
    
    4.集合👆三种
    def huangjingchu(arg1, /, arg2, *, arg3)
    >>> huangjingchu(1, 1, arg3 = 1) | huangjingchu(1, arg2 = 1, arg3 = 1)
    ```

  - 概括

    - 仅限位置形参：希望形参名称对用户不可用 | 形参名称无实际意义 | 希望调用参数顺序
    - 仅限关键字形参：参数名称有意义 | 显示参数名可使函数易理解 | 想防止用户过于依赖传入参数位置
    - 对API好处：仅限位置形参可防止形参名在以后被修改时造成破坏性的API变动

- 任意的参数列表

  - 不常用的选项是可用任意数量的参数（元组）调用函数

- 解包参数列表

  - 可以使用`*`操作符从列表或元组中解包参数

  - 可以使用`**`操作符从 字典 解包关键字参数

  - ``` python
    # 例一
    arg = [0, 5]
    range(*arg)
    
    # 例二
    def method(huang, jing = 0, chu = 0)
    arg = { "huang": 1, "jing": 2, "chu": 3}
    method(**arg)
    ```

- Lambda 表达式

  - 可创建匿名函数

  - 可在需要函数对象的任何地方使用

  - 语法限于单个表达式

  - 正常函数定义的语法糖

  - ```pythonn
    def example(num):
    	return lambda x: x + num
    >>> met = example(10)
    >>> met(1)
    11
    ```

- 文档字符串

  - 第一行：对象目的的简述

  - 如多行，第二行应为空白

  - 后几行应为一或多个段落，描述对象调用约定和副作用

  - ```python
    def simple():
        '''这是一个函数文档字符串.
    
        This is a Function Doc string.
        '''
        pass
    
    print(simple.__doc__) # 打印函数文档
    ```

- 函数标注

  - 关于自定义函数中使用的类型的完全可选原数据信息

  - 形参标注：在参数后面加冒号和表达式

  - 返回值标注：在`def`语句结束的冒号前加上 `->`和表达式

  - 会以字典形式存放在函数的`__annotations__`属性中

  - ```python
    def simple(huang, jing: str = "chu") -> str:
        print(simple.__annotations__)
        
    >>> {'jing': <class 'str'>, 'return': <class 'str'>}
    ```

- 编码风格

  - 4空格缩进
  - 每行不超过79个字符
  - 空行分隔函数、类和较大代码块
  - 注释尽量能单独一行
  - 使用文档字符串
  - 使用AbCd驼峰命名类
  - 使用A_B_C命名函数
  - 默认UTF-8或纯ASCII

# 4. 数据结构

## 列表其他特性

- `list.append( x )`：在列表末尾插入 x 值
- `list.extend( iterable )`：在列表末尾并入 iterable 中所有元素
- `list.insert( i, x )`：在列表 i 位置，插入 x 值
- `list.remove( x )`：删除列表第一个 x 值
- `list.pop( [ i ] )`：删除列表第 i 位置的值或最后一个值
- `list.clear( )`：清除列表中所有元素
- `list.index( x[, start[, end]] )`：返回在列表中找到 x 的位置
- `list.count( x )`：返回 x 在列表中出现的次数
- `list.sort( key=None, reverse=Flase )`：对列表中的元素进行排序
- `list.reverse( )`：反转列表中的元素
- `list.copy( )`：返回列表的一个浅拷贝

## 列表作为栈使用

- 后进先出
- 列表末尾添加和弹出元素非常效率
- 使用`list.append( )` 和 `list.pop( ) 实现

## 列表作为队列使用

- 先进先出

- 因每次移动，都使列表元素均移动一位，所以低效

- 如非要实现队列，可使用`collections.deque`（设计快速从两端操作）

- ``` python
  from collections import deque
  ary = deque(['huang', 'jing', 'chu'])
  ary.append('new')
  ary.popleft() # 移出第一个
  ```

## 列表推导式

- 提供更简单的创建列表的方法

- ```python
  list(map(lambda x: x**2, range(10)))
  ```

- 结构：一对方括号所包含一个表达式，后跟一个`for`子句，然是零或多个`for` | `if`子句

- ```python
  [ x**2 for x in range(10) ]
  ```
- ```python
  # 复杂点
  [ (x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y ]
  # 等于如下
  ary = []
  for x in [1, 2, 3]
  	for y in [3, 1, 3]
    	if x != y:
        ary.append((x, y))
  ```

## 嵌套的列表推导式

- 初始表达式可以是任何表达式，包括另一个列表推导式

- ```python
  ary = [ [1, 2, 3, 4], [11, 22, 33, 44] ]
  [ [ row[i] for row in ary  ] for i in range(4) ]
  ```

- ```python
  # 使用`zip()`函数实现上面方法
  list(zip(*ary))
  ```

## `del`语句

- 通过给定索引进行删除列表元素
- 可从列表中移除切片
- 可清空整个列表
- 可删除整个变量

## 元组和序列

- 元组是不可变的（immutable）
- 含一元素的元组，可在这元素后面加一逗号
- 打包：`name = 'huang', 'jing', 'chu!'`
- 解包：a, b, c = name
- 解包操作等号右侧可以是任何序列，要求左侧的变量数与右侧序列里所含的元素数相同

## 集合

- 由不重复元素组成的无序的集
- 基本用法：成员检测 | 消除重复元素
- 支持：联合 | 交集 | 差集 | 对称差分 ...数学运算
- 创建：`{ value }` | `set()` 
- 支持推导式

## 字典

- 内置数据类型
- 键值对的集合，键必须唯一
- 关键字为索引，关键字可为任意immutable类型
- 使用`{}`可创建空字典
- 主要操作：用关键字存储和解析值
- 可用`del`来删除键值对
- 对一个字典类型使用 `list(dic)`将返回字典所有键的列表
- 使用 `in` | `not in` 来判断是否存在特定键
- 支持推导式
- `dict()` 可从键值对序列里创建字典 | 关键字为字符串时，可直接通过指定键值创建

## 循环技巧

- 循环字典时，用 `items()` 方法导出键值
- 循环序列时，用 `enumerate()` 方法导出索引
- 循环多个序列时，用`zip()`方法将其内元素一一匹配
- 逆向循环序列时，先正向定位序列，再用`reversed()`
- 按照某顺序循环序列，用`sorted()`可不懂原序列的基础上返回新排好序的序列
- 如要在循环时修改内容，最好改为创建一个新列表是比较简单且安全的

## 深入条件控制

- `while` | `if` 语句中可用任意操作
- `in` | `not in` 校验一个值是否在一个序列里
- `is` | `is not` 比较两个对象是否同个对象
- 比较操作可以传递
- 比较操作可配合 `not` |  `and` | `or` 

## 序列和其他类型的比较

- 序列对象通常可与相同序列类型的其他对象比较
- 比较法：字典式顺序 | 对比元素（如有子元素则递归比较） > 对比数量
- 字典式顺序使用 Unicode 码位序号对单个字符序列
- 对不同类型对象来说，只要待比较对象提供合适比较方法，就可以使用`<`和`>`来比较

# 模块

- 模块中可定义可以导入到其他模块或主模块中
- 模块是包含`python`定义和语句的文件

## 有关模块的更多信息

- 模块仅在第一次 import 语句中被导入时才执行
- 每个模块都有私有符号表
- 将模块中某名称方法导出到现模块：`from MODULE import FUN1, FUN2`
- 将模块内所有名称导出：`from MODULE import *`
- 将模块导出且命名：`import MODULE as NEWNAME` | `from MODULE import FUN as NEWNAME`

### 以脚本的方式执行模块

1. 命令行运行模块：`python NAME.py <arguments>`

2. 模块代码被执行，`__name__`被赋值为`__main__`

3. 可通过在模块末尾添加代码使其可在命令行执行

4. ```python
   # NAME.py
   if __name__ == "__main__":
     import sys
     examply(sys.argv[1])
   ```

### 模块搜索路径

- 当导入一个`xxx`模块时
  1. 解释器寻找该名称的内置模块
  2. 没找到则从`sys.path`给出的目录列表中寻找`xxx.py`文件
     - 包含输入脚本的目录
     - PYTHONPATH：包含目录名称列表
     - 取决安装默认设置
  3. 包含符号链接的目录没有被添加到模块的搜索路径上

### 编译过的Python文件

- 为加速模块载入，`__pycahce__`目录会缓存各模块编译后的版本
- 根据编译版本检查源的修改日期，以便过期重新编译（完全自动化过程）
- 不检查缓存的两种情况：
  1. 命令行直接载入的模块，重新编译且不存编译结果
  2. 没有源模块，不会检查缓存
- 为支持无源文件（仅编译）发行版本，编译模块必须在源目录下，且不能有源模块
- `.pyc`文件唯一快的地方是：载入速度

## 标准模块

- Python附带一个标准模块库
- 一些模块内置于解释器中
- 如`sys`模块被内嵌到每个解释器中

## `dir()`函数

- 属于内置函数，用于查找模块定义的名称，返回一个排序过的字符串列表
- 无参数调用会列出当前定义的名称列表
- 列出所有类型的名称：变量、模块、函数、等等..
- 默认不会列出内置函数/变量的名称，它们定义在标准模块中：`import builtins > dir(builtins)`

## 包

- 一种通过用“带点号的模块名”来构造模块命名空间的方法
- 使模块包的作者不用担心名称一致的问题
- Python只把含有`__init__.py`文件的目录当做包
- 可以通过`from PACKAGE import NAME` 或 `import PACKAGE1.PACKAGE2.NAME`来导出所需函数或变量

### 从包中导入 `*`

- 如`from PACKAGE import *`会将包中的全部子模块导入（有副作用）
- 一个包的`__init__.py`文件定义了`__all__`列表，那么当导入 `*` 时，将导入子模块到当前命名空间

### 子包参考

- 可用绝对导入来引用兄弟包的子模块

- 可用`import`来形式编写相对导入
  - 基于当前模块名称进行导入
- 主模块的名称总是"__main__"，主模块必须使用绝对导入

### 多个目录中的包

- 支持特殊属性：`__path__`列表

# 输入输出



## 漂亮的输出格式

- 格式化输出方法

  - 格式化字符串字面值：

    1. 在字符串的开始引号前加`f`|`F`
    2. 在`{}`中放入引用变量 | 表达式

    - ```python
      name = 'jingchu'
      f"My name is {name}"
      ```

  - 方法：`str.format()`

    - ```python
      'my name is {}'.format('jingchu')
      ```

	- 可用`str()`和`repr()将任何值转为字符串`


### 格式化字符串文字

- 简称 f-字符串
- `:`后面传递一个整数可让字段成为最小字符宽度
- 其他的修饰符可用于在格式化之前转化值
	- `!a`应用`ascii()`
	- `!s`应用`str()`
	- `!r`应用`repr()`

### 字符串的`format()`方法

- 字符串中的`{}`和其中的字符称为格式字段
- 字段会替换传递给`str.format()`方法的对象，其中数字可以表示位置
- `str.format()`使用关键字参数时，格式字段需要使用键引用它们
- 对于长格式字符串，也可以采用简单传递字典和使用`[]`访问键来完成
- `str.format(**arg)`可通过解包字典参数，来代替上面的方式

### 手动格式化字符串
- 通过`str.rjust()`在左侧填充空格
- `str.zfill()`在左边填充零，可识别正负
- 类似方法还有：`str.ljust()` 、`str.center()`

### 旧的字符串格式方法

- 使用`%`操作符来格式化字符串

  - ```python
    print('my name is %s' % 'leo')
    ```

## 读写文件

- `open(filename, mode)`返回一个文件对象，
  - `mode`参数：`r`只读（默认） | `w`只写 | `a`追加内容 | `r+`读写 | `b` 二进制
- 处理文件对象，最好用`with`关键字，当子句体结束后文件会正确关闭
- 无用`with`关键字时，得用`close()`关闭文件和释放资源，不显示关闭会导致文件持续打开一段时间

### 文件对象方法

- fileObject.`read()`：读取文件内容
- fileObject.`readline()`：从文件中读取一行
- `list(fileObject)`和fileObject.`readlines()`：读取所有行
- fileObject.`write()`：写入字符串
- fileObject.`tell()`：返回一个整数，文件对象在文件中的当前位置
- fileObject.`seek(offset, whence)`：改变文件对象的位置

### 使用`json`保存结构化数据

- JSON的标准模块可采用Python数据层次结构，并将它们转化为字符串表示形式（序列化过程）
- 从字符串表示中重建数据称为反序列化（deserializing）
- `json.dumps()`：序列化字符串
- `json.loads()`：反序列化字符串
- `json.dump()`：序列化文件
- `json.load()`：反序列化文件

# 错误和异常

## 语法错误 | 解析错误

- 常见
- 箭头指向的token导致

## 异常

- 不一定导致严重后果
- 不会被程序处理
- 标准的异常类型是内置的标识符

## 处理异常

- 可编写处理所选异常的程序
- `try`语句
  - 无发生异常，跳过`except`子句并完成`try`语句的执行
  - 执行`try`子句时发生异常，则跳过剩余部分，然如果异常的类型与`except`关键字后异常匹配，则执行`except`子句，接着继续`try`语句后的代码
  - 如发生的异常和`except`子句指定异常不匹配，则将其传到外部`try`语句中；如没找到，则为一个未处理异常，会导致执行停止并显示异常消息
  - `except`子句可将多个异常命名为带括号的元组
  - 发生的异常和`except`子句中的类是同一个或者它的基类，则异常和`except`子句中的类是兼容的
  - `except`子句可省略异常名来用作通配符，应慎用
  - `try...except`语句有一可选`else`语句，对`try`子句不引发异常时必须执行的代码很有用
  - `except`子句可在异常名称后面指定一个变量：`except Error as variable`
  - 异常处理程序可处理`try`子句中遇到的异常和其中调用的函数内部发生的异常

## 抛出异常

- `raise(Error)`语句允许强制发生指定的异常
- 不打算处理它，可简单的用`raise`语句来重新引发异常

## 用户自定义异常

- 可创建新的异常类来命名异常
- 通常应该从Exception类派生
- 定义异常类可执行其他类可执行的任何操作，保持简单，一般提供多属性处理程序为异常提取错误信息
- 创建可能引发多个不同错误的模块时，应为模块定义的异常创建基类，并为不同错误条件创建相应子类
- 命名最好以Error结尾，类似标准命名

## 定义清理操作

- `finally`：`try`的可选子句，作用于清理操作
- 作为`try`语句结束前最后一项任务被执行（不管如何都会执行）
- 它的`return`会替代try的`return`
- 最终都会执行
- 游泳与释放外部资源（文件或网络连接）

## 预定义的清理操作

- 不再需要某对象时要执行的标准操作

- 例如打开文件后，一段时间内会处于打开状态，对于大应用这是值得优化问题

- 使用好with`语句可以确保像文件对象得到及时正确的清理方式

- ```python
  with open(file) as file
  	for line in file:
      pass
  ```

# 类

- 提供了一种组合数据和功能的方法
- 一个类等于一个对象类型
- 类可以有多个实例
- 实例可以拥有保存自己状态的属性和改变状态的方法
- 提供了面向对象编程所有标准特性
  - 继承机制允许多个基类
  - 派生类可覆盖其基类的任何方法
  - 可调用基类方法
  - 对象可包含任意数量和类型的数据
- 具备动态特性：
  - 运行时创建
  - 创建后可修改

## 名称和对象

- 多个名称可绑定同一对象

## 作用域和命名空间

- 命名空间是从名字到对象的映射
- 不同命名空间中的名称之间绝对没关系
- 任何跟在一个点号后面的名称都称为属性
- 不同时刻创建的命名空间有不同的生存期
- 函数的本地命名空间在被调用时创建，返回或抛错时删除
- 作用域被静态确定，但被动态使用
  - 最先搜索最内部作用域包含局部名称
  - 从最近的封闭作用域开始搜索任何封闭函数的作用域包含非局部名称，也包括非全局名称
  - 倒数第二个作用域包含当前模块的全局名称
  - 最外面的作用域是包含内置名称的命名空间（最后搜索）
- 一个名称被声明为全局变量，则所有引用和赋值将直指包含该模块的全局名称的中间作用域
- 重新绑定在最内层作用域以外找到的变量，可用`nonlocal`语句声明为非本地变量
- 作用域按字面文本来确定：
  - 在一个模块内定义的函数的全局作用域就是该模块的命名空间
  - 实际的名称搜索是在运行时动态完成的
- Python正在朝着“编译时静态名称解析”的方向发展
- `global`语句可用来表明特定变量生存于全局作用域并且应当在其中被重新绑定
- `nonlocal`语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定

### 示例

- 默认局部赋值
- `nonlocal`可找到给上一层作用域的名称
- `global`找到最外层名称

## 初探类

- 三种新对象类型
- 一些新语义

### 类定义语法

- ```python
  class ClassName:
  ```

- 类定义与函数定义一样必须被执行才会起作用（实践中，通常以函数定义来定义类）

- 类内部通常有一种特别形式的参数列表

- 定义类时，将创建一个命名空间（也是局部作用域），所有对局部变量的赋值都在这空间内

### 类对象

- 支持操作：属性引用 | 实例化
- 属性名称是类创建时存在于命名空间中的名称
- 实例化操作会创建一个空对象
- 通过定义类的`__init__()`属性，来使实例带有特定初始化状态

### 实例对象

- 有效属性名称：数据属性 | 方法
- 数据属性不需要声明
- 方法是属于对象的函数
- 类中所有函数对象的属性都定义了其实力的相应方法
- 实例的方法对象 为 类的函数对象

### 方法对象

- 特殊之处：实例对象会作为方法函数的第一个参数被传入
- 意味着：调用实例方法需要N个参数，我们就需要传给它N+1个参数
- 原理过程：实例的的非数据「属性」被调用时，会先在父类中查找这个「属性」，如果找到，那么实例和函数会创建该方法对象，当附带参数列表调用方法时，将基于实例对象和参数列表构建新参数列表，然后使用新列表调用该函数方法对象

### 类和实例变量

- 实例变量只用于实例
- 类变量作用于所有实例
- 注意类的共享数据中别用可变对象（除非需要）

## 补充说明

- 同名问题，优先选择实例属性
- Python中没有任何东西能强制隐藏数据——基于约定（可通过扩展来解决）
- 避免名称冲突
- 方法内部引用属性方法没有简便方式（利于可读）
- 方法第一个参数常常命名为`self`——基于约定
- 每个对象都具有类（类型），储存为`object.__class__`

## 继承

- ```python
  class DerivedClassName(BaseClassName):
  ```

- 派生类定义的执行跟基类相同

- 当构造派生类时，会记住基类，当请求属性在派生类中找不到，就会到基类中区寻找，直至顶层

- 没有特殊之处，其实例方法引用按自身搜索，如没有，会从基类继承链逐步查找

- 派生实例方法可覆盖基类方法

- 可通过`BaseClassName.methodname()`调用基类方法

- 内置函数继承机制：`isinstance()` | `issubclass()`

### 多重继承

- ```python
  class DerivedClassName(Base1, Base2, Base3)
  ```

- 搜索继承操作是深度优先，从左至右

- 方法解析顺序会动态改变以支持对`super()`的协同调用

## 私有变量

- Python不存在仅限从一对象内部访问的“私有”实例变量
- 无论函数、方法还是数据成员，带有一个下划线的名称应该被当作API的非仅供部分（如：`_name`）——约定
- 因存在对私有成员的使用场景，所以存在对这种机制的有限支持，成为名称改写（避免名称冲突）
- 任何形式为`__NAME`或`__NAME_`的标识符会被替换为`_CLASSNAME__NAME`

## 杂项说明

- 有时需要一些数据类型，将些命名数据捆绑一起，可定义一个空类
- 实例方法的属性：`METHOD.__self__`就是带有`METHOD()`方法的实例对象
- 实例方法的属性：`METHOD.__func__`就是方法对应的函数对象

## 迭代器

- `for`语句的幕后，会在容器对象上调用`iter()`，该函数返回一个定义了`__next__()`方法的迭代器对象，该方法逐一访问容器内部元素，当元素用尽，则抛出`StopIteration`异常来结束`for`循环

- ```python
  test = '123'
  item = iter(test)
  next(item)
  ```

## 生成器

- 用于创建迭代器的简单强大工具
- 写法类似标准函数
- 返回数据使用`yield`语句
- 便于编写创建迭代器
  - 每次对生成器调用`next()`，会从上次离开位置恢复执行（且记住上次数据）
  - 会自动创建`__iter__()`和`__next__()方法`
  - 局部变量和执行状态会在每次调用之间自动保存
  - 终结时会引发`StopIteration`

## 生成器表达式

- 使用类似列表推导式来编写简洁的表达式代码
- 外层为圆括号
- 用于立即被外层函数调用的情况
- 比完整的生成器更紧凑，但比较不灵活
- 比等效的列表推导式则更节省内存

	# 标准库简介（1）



## 操作系统接口

- `os`模块：提供与操作系统交互的函数
- `shutil`模块：提供更高级的接口
- `dir`模块：
- `help`模块：可查看模块的使用指南

## 文件通配符

- `glob`模块：提供一个在目录中使用通配符搜索创建文件列表的函数

## 命令行参数

- 通用实用程序脚本通常需要处理命令行参数，这些参数会作为列表存储于`sys`模块的`argv`属性中
- `argparse`模块：提供一种更复杂的机制来处理命令行参数

## 错误输出重定向和程序终止

- `sys`模块的`stdin`，`stdout`，`stderr`和`exit`属性
- `stderr`有用于发出警告和错误消息
- `stdout`有用于重定向
- `exit`用于终止脚本

## 字符串模式匹配

- `re`模块：为高级字符串处理提供正则表达式工具

## 数学

- `math`模块：提供浮点数学的底层C库函数的访问
- `random`模块：提供随机选择的工具
- `statistics`模块：计算数值数据的基本统计属性

## 互联网访问

- `urllib`模块：用于从URL检索数据
- `smtplib`模块：用于发送邮件

## 日期和时间

- `datetime`模块：提供简单和复杂的方式操作日期和时间的类

## 数据压缩

- `zlib`模块：支持常见的数据存档和压缩格式（zlib, gzip, bz2, lzma, zipfile, tarfile）

## 性能测量

- `timeit`模块：可快速演示在运行效率方面一定的优势
- `profile`和`pstats`模块：提供用在较大代码块中识别时间关键部分的工具

## 质量控制

- 开发高质量软件的一种方法，是在开发过程中为每个函数编写测试，并开发过程常运行这些测试
- `doctest`模块：用于扫描模块并验证程序文档字符串中嵌入的测试
- `unittest`模块：允许在单独的文件中维护更全面的测试集

## 自带电池

- 通过其包的复杂和强功能可最好地看到“自带电池”的理念

# 标准库简介（2）

> 涵盖专业编程所需的高级模块，很少应用于小脚本

## 格式化输出

- `reprlib`模块：提供一个定制化版本的`repr()`函数，用于缩略显示大型或深层嵌套的容器对象
- `pprint`模块：提供更复杂的打印控制，输出的内置对象和用户自定义对象能够被解释器直接读取
- `textwrap`模块：能够格式化文本段落，适应给定宽度
- `locale`模块：处理与特定地地域文化相关的数据格式，其`format`函数可将数字格式为带有分隔符的样式

## 模板

- `Template`类：属于`string`模块，适用简化语法，允许在不更改应用逻辑的情况下定制自己的应用
  - 占位符为`$`，`$$`会转义为单个
  - `${}`后面可连接字符组成新字符串
  - `substitute`、`safe_substitute`为占位符提供值
- 可自定义定界符
- 将程序逻辑与多样的格式化输出细节分离开来。使得对 XML 文件、纯文本报表和 HTML 网络报表使用自定义模板成为可能

## 使用二进制数据记录格式

- `struct`模块：提供了`pack`和`unnpack`函数，用于处理不定长度的二进制记录格式

## 多线程

- 线程：对没顺序的多个任务进行解耦的技术

- 多线程可提供应用响应效率，可同时处理不同任务

- 面临挑战：相互协调多个线程之间需要共享数据或其他资源

- `threading`模块：提供多个同步操作原语（包括线程锁、事件、条件变量、信号量）

- 因微小的设计错误可导致难以复现的问题，所以，实现多任务写做的首选方法：👍

  1. 将对资源的所有请求集中于一个线程

  2. 使用`queue`模块向该线程供应来自其他线程的请求
     - 应用使用`queue`进行线程间通信和协调，会易于设计、易读、可靠

## 日志

- `logging`模块：提供功能齐全且灵活的日志记录系统
- 日志系统可从`Python`配置或从用户配置文件加载

## 弱引用

- `Python`会自动进行内存管理（某对象的最后一个引用被移除后不久就会释放其所占用的内存）
- 偶尔必须在对象持续被其他对象所引用时跟踪它们，但是跟踪会创建一个令其持久化的引用
  - `weakred`模块：可不必创建引用就能跟踪对象，当对象不再需要时，将自动从一个弱引用表中被移除，并为弱引用对象触发一回调

## 用于操作列表的工具

- 许多对于数据结构的需求可以通过内置列表类型来满足，但有时也需要具有不同的类型代替实现
- `array`模块的`array()`对象，类似列表，只能存储「类型一致」的数据且「存储秘籍」更高
- `collections`模块的`deque()`对象，类似列表，从左端添加和弹出速度较快，而在中间查找较慢，适用于实现队列和广度优先树搜索
- `bisect`模块的`insort()`对象，有助于操作排序列表的函数
- `heapq`模块：提供基于常规列表来实现堆的函数，最小值得条目总保持在位置0
  - 对于需要重复访问最小元素而不希望运行完整列表排序的应用非常有用

## 十进制浮点运算

- `decimal`模块：提供一种`Decimal`数据类型用于十进制浮点运算
- 适用：
  - 财务应用和其他精确十进制表示的用途
  - 控制精度
  - 控制四舍五入以满足法律或监管要求
  - 跟踪有效小数位
  - 用户期望结果与手工完成的计算相匹配的应用程序
- `Decimal`可模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题

# 虚拟环境和包

## 概述

- Python 应用程序通常会使用不在标准库内的软件包和模块
- 应用程序有时需要特定版本的库，因为应用程序可能需要修复特定错误（意味一个Python安装可能无法满足每个应用的要求）
- 解决方案是创建不同的`virtual environment`（虚拟环境）来放不同的特定版本以及包，不同的应用可用不同的环境，之间不互相影响

## 创建虚拟环境

- 用于创建和管理虚拟环境的模块称为：`venv`
- 本人用的是独立于外的`pyenv`进行版本管理

## 使用pip管理包

- 用于安装、升级、移除软件包
- 默认从 [Python Package Index](https://pypi.org) 安装软件包
- 安装指定：`pip install PACKAGE`
- 安装版本：`pip install PACKAGE==VERSION`
- 安装最新版：`pip install --upgrade PACKAGE`
- 删除指定：`pip uninstall PACKAGE PACKAGE`
- 显示包信息：`pip show PACKAGE`
- 显示环境中的包列表：`pip list`
- 生成一个类似已安装列表：`pip freeze > NAME.TXT `
- 更详细的通过 [网站指南](https://pypi.org/) 或`pip -h`

# 接下去

> 一些问题传送门

- [标准库](https://docs.python.org/zh-cn/3/library/index.html#library-index)：应阅读，提供标准库中的类型，功能和模块的完整参考资料（提升广度）
- [The Python Package Index]([https://pypi.org](https://pypi.org/))：可下载用户自制Python模块（相当NPM -，-）
- [语言参考](https://docs.python.org/zh-cn/3/reference/index.html#reference-index)：语法语义的详尽解释（提升深度）
- [Ecientific Python项目](https://scipy.org/)：包括用于快速阵列计算和操作模块，以及用于诸如线性代数，傅里叶变换，非线性求解器，随机数分布，统计分析等的一系列包
- [文档]([https://docs.python.org](https://docs.python.org/) )：快速访问

# 交互式编辑和编辑历史

## Tab 补全和编辑历史

- 解释器启动的时候，补全变量和模块名的功能将 [自动打开](https://docs.python.org/zh-cn/3/library/site.html#rlcompleter-config)
- 默认配置下会把编辑历史记录保存在用户目录下名为 `.python_history` 的文件

## 默认交互解释器的代替品

- 一个可选的增强型交互式解释器是IPython
- 其实....PyCharm 就可以解决这篇文章想解决的问题了..（目前所用的编辑器）

# 浮点算数：争议和限制

- 无论使用多少位以 2 为基数的数码，十进制的 0.1 都无法精确地表示为一个以 2 为基数的小数
- 今天的大部分架构上，浮点数都只能近似地使用二进制小数表示
- 大多数人不会意识到这个差异的存在，因 Python 只会打印计算机中存储的二进制值的十进制近似值
- 牢记，即使输出的结果看起来好像就是 1/10 的精确值，实际储存的值只是最接近 1/10 的计算机可表示的二进制分数
- 有趣的是，有许多不同的十进制数共享相同的最接近的近似二进制小数
- 从 Python 3.1 开始，Python（在大多数系统上）现在能够选择这些表示中最短的并简单地显示 `0.1`
- 注意这种情况是二进制浮点数的本质特性：它不是 Python 的错误，也不是你代码中的错误。 你会在所有支持你的硬件中的浮点运算的语言中发现同样的情况
- 不必过于担心浮点数的问题！ Python 浮点运算中的错误是从浮点运算硬件继承而来
- 记住它并非十进制算术，且每次浮点运算都可能会导致新的舍入错误
- 对于需要精确十进制表示的使用场景，请尝试使用 [`decimal`](https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal) 模块，该模块实现了适合会计应用和高精度应用的十进制运算
- `math.fsum()` 函数，它有助于减少求和过程中的精度损失

## 表示性错误

- *表示性错误* 是指某些（其实是大多数）十进制小数无法以二进制（以 2 为基数的计数制）精确表示这一事实造成的错误

# 附录

## 交互模式

### 错误处理

- 当发生错误时，解释器会打印错误信息和错误堆栈

### 可执行的Python脚本

- 在BSD等类Unix系统上，Python脚本可直接执行，只需在第一行添加：
  - `#!/usr/bin/env python3.8
- 可用 `chmod` 命令为脚本提供可执行模式或权限
  - `chmod +x NAME.py`

### 交互式启动文件

- 当用交互方式使用Python时，每次启动解释器时都会执行一些标准命令，这通常很方便。
- 可以通过将名为 [`PYTHONSTARTUP`](https://docs.python.org/zh-cn/3/using/cmdline.html#envvar-PYTHONSTARTUP) 的环境变量设置为包含启动命令的文件名来实现

### 定制模块

- Python提供了两个钩子来让你自定义它：`sitecustomize` 和 `usercustomize`





时间：2020年01月31日02:18:22

